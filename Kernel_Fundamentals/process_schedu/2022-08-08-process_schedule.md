# 进程调度

> 内核基本原理
>
> 调度、进程调度
>
> CPU是计算机系统中的最重要的资源，是操作系统的管理对象。

## 什么是调度

* 调度：CPU 资源管理器。

* 内核进程调度：对 CPU **进行时间分割管理**的具体做法就叫做进程调度。

* 进程调度和线程调度：进程是资源分配的单位，线程是执行的单位。进程调度调度的就是线程，习惯叫做进程调度。

* 线程调度的两种方式：

    * 一种是直接调度线程，不考虑它们所属的进程，这种方式叫做直接调度或者一级调度；
    * 一种是先调度进程，再在进程内部调度线程，这种方式叫做间接调度或者二级调度。**POSIX **规定，操作系统可以选择这两种方式中的任何一种都行。

* Linux 选择的调度方式：

    ​		**内核选择一级调度**，为什么会这么选择呢？**主要是为了提高进程的并发性**，充分利用多 CPU 多核的优势。如果使用二级调度的话，看似每个进程之间都公平了，但是有些进程的计算量比较大，就**无法通过多开线程提高自己的性能**，这样对系统整体的性能是有害的，也不利用发挥计算机多 CPU 的优势。一级调度看似对有些进程不公平，但是计算量小的进程少开线程，计算量大的进程多开线程，相对还是很公平的。

## 为什么要调度

* 协作式多任务：当程序由于要等 IO 而阻塞时就会去调度执行其它的进程。但协作式多任务存在着很大的问题，就是每个进程运行的**时间片长短是不确定的**，而且是很偶然很随机的。

* 道德解决方案：如果一个进程它一直在做运算就是不进行IO操作，那么它就会一直霸占CPU。针对这个问题，当时想出的方法是道德解决方案。内核向进程提供系统调用sched_yield，它会使**进程主动放弃**CPU让其它进程来执行。

* 抢占式多任务：使得每个进程都可以相对公平地平分CPU时间，如果一个进程运行了过长的时间就会被强制性地调度出去，不管这个进程是否愿意。抢占式多任务和协作式多任务不是对立 的，它们是相互独立的，可以同时存在于系统中。

* 用户抢占和内核抢占：

    * 如果抢占点是在用户空间，那么抢占就是安全的，如果在内核空间就不一定安全，这是为什么呢？因为对于用户空间来说，如果抢占会导致线程同步问题，那么用户空间有责任使用线程同步机制来保护临界区，只要用户空间做好同步就不会出问题。
    * 如果内核也做好了同步措施，内核抢占也不会出问题，但是内核最初的设计就没有考虑内核抢占问题，所以刚开始的时候内核是不能抢占的。后来内核开发者对内核进行了完善，把**内核所有的临界区都加上了同步措施**，然后内核就是可抢占的了。

* 现在看为什么要调度：因为如果没有调度的话，就不能实现多任务，一次就只能运行一个程序，我们使用电脑的体验就会大大降低。有了调度就有了多任务，我们就能同时在电脑上做很多事情，使用体验就会非常好。

## 为什么能调度

* 主动调度和被动调度：协作式多任务是主动调度，抢占式多任务是被动调度。

* 为什么能触发调度?

    对于主动调度，调度是进程主动触发的，肯定是能的。

    对于被动调度，能做到的关键原因是中断机制。有了中断机制，我们就可以创建一个定时器中断，以固定的时间间隔比如每10ms来触发中断，检测进程是否运行时间过长，如果过长就触发调度。

* 为什么能执行调度？

    * 选择进程：纯软件实现
    * 切换进程：主要是切换执行栈和用户空间，都需要CPU特定指令支持。

## 调度时机

* 主动调度时机：IO等待、加锁失败等各种阻塞操作以及用户控件主动调用sched_yield。
* 被动调度时机：
    * 定时器中断发现当前进程超时
    * 在唤醒进程时发现新进程需要抢占当前进程
    * 在迁移进程时发现新进程需要抢占当前进程
    * 在改变进程优先级时发现新进程需要抢占当前进程

## 如何调度

* 执行调度分为两步
    * 一是进程选择：调度算法，进程分类
    * 二是进程切换：第一步是切换用户空间，第二步是切换执行栈

## 调度均衡

* 使用条件：多个CPU会进行调度均衡
* 分类：个体均衡和总体均衡

## 调度器评价

